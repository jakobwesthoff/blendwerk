<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>blendwerk - File-based mock HTTP/HTTPS server</title>
  <meta name="description" content="A file-based mock HTTP/HTTPS server where your directory structure IS the API. Hot-reload, YAML frontmatter, path parameters.">

  <!-- Favicon -->
  <link rel="icon" type="image/svg+xml" href="favicon.svg">

  <!-- Prism.js syntax highlighting -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.30.0/themes/prism-tomorrow.min.css" integrity="sha512-vswe+cgvic/XBoF1OcM/TeJ2FW0OofqAVdCZiEYkd6dwGXthvkSFWOoGGJgS2CW70VK5dQM5Oh+7ne47s74VTg==" crossorigin="anonymous" referrerpolicy="no-referrer">

  <!-- CSS imports in dependency order -->
  <link rel="stylesheet" href="styles/theme.css">
  <link rel="stylesheet" href="styles/base.css">
  <link rel="stylesheet" href="styles/components.css">
  <link rel="stylesheet" href="styles/utilities.css">
  <link rel="stylesheet" href="styles/layout.css">
</head>
<body>
  <!-- Navigation -->
  <nav class="navbar">
    <div class="container navbar-inner">
      <a href="#" class="navbar-brand">
        <span>blendwerk</span>
      </a>

      <ul class="navbar-nav">
        <li><a href="#demo">Demo</a></li>
        <li><a href="#quickstart">Quick Start</a></li>
        <li><a href="#docs">Documentation</a></li>
      </ul>

      <div class="navbar-actions">
        <a href="https://github.com/jakobwesthoff/blendwerk" class="btn btn-secondary btn-sm">
          <svg class="icon-github" viewBox="0 0 24 24">
            <path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/>
          </svg>
          GitHub
        </a>
        <a href="#quickstart" class="btn btn-primary btn-sm">
          <svg class="icon-download" viewBox="0 0 24 24">
            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
            <polyline points="7 10 12 15 17 10"/>
            <line x1="12" y1="15" x2="12" y2="3"/>
          </svg>
          Quick Start
        </a>
      </div>
    </div>
  </nav>

  <main>
    <!-- Hero Section -->
    <section class="hero">
      <div class="container">
        <h1>blendwerk</h1>
        <p class="hero-subtitle">[&#x2C8;bl&#x25B;ntv&#x25B;rk] &mdash; German: illusion, deceptive appearance.</p>
        <p class="hero-tagline">
          A file-based mock HTTP/HTTPS server where your directory structure IS the API. No databases, no config files &mdash; just directories and text files.
        </p>
        <div class="hero-actions">
          <a href="#quickstart" class="btn btn-primary btn-lg">
            <svg class="icon-download" viewBox="0 0 24 24">
              <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
              <polyline points="7 10 12 15 17 10"/>
              <line x1="12" y1="15" x2="12" y2="3"/>
            </svg>
            Quick Start
          </a>
          <a href="https://github.com/jakobwesthoff/blendwerk" class="btn btn-secondary btn-lg">
            <svg class="icon-github" viewBox="0 0 24 24">
              <path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/>
            </svg>
            View on GitHub
          </a>
        </div>
      </div>
    </section>

    <!-- Highlights - key value props, no section title -->
    <section id="features" class="highlights">
      <div class="container">
        <div class="highlights-grid">
          <div class="highlight">
            <h3>Directory = API</h3>
            <p>Your directory structure IS your API. Folders become URL paths, filenames become HTTP methods. No config files, no databases.</p>
          </div>
          <div class="highlight">
            <h3>Ready in Seconds</h3>
            <p>Create a file, run blendwerk, done. Hot-reload lets you incrementally build your mocks as you develop and test.</p>
          </div>
          <div class="highlight">
            <h3>SSL Out of the Box</h3>
            <p>Self-signed certificates generated automatically. Test your HTTPS clients without certificate hassle. Custom certs supported too.</p>
          </div>
        </div>
      </div>
    </section>

    <!-- Demo Section -->
    <section id="demo" class="demo">
      <div class="container">
        <div class="demo-window">
          <div class="macos-window">
            <div class="macos-window-titlebar">
              <div class="macos-window-buttons">
                <span class="macos-window-button close"></span>
                <span class="macos-window-button minimize"></span>
                <span class="macos-window-button maximize"></span>
              </div>
              <span class="macos-window-title">Terminal</span>
            </div>
            <div class="macos-window-content">
              <video autoplay loop muted playsinline>
                <source src="assets/demo.webm" type="video/webm">
                <source src="assets/demo.mp4" type="video/mp4">
              </video>
            </div>
          </div>
        </div>
      </div>
    </section>

    <!-- Quick Start Section -->
    <section id="quickstart" class="quickstart">
      <div class="container">
        <div class="quickstart-content">
          <h2>Quick Start</h2>

          <div class="tabs">
            <div class="tab-buttons">
              <button class="tab-button active" data-tab="cargo">Cargo (Recommended)</button>
              <button class="tab-button" data-tab="binary">Binary Releases</button>
              <button class="tab-button" data-tab="source">From Source</button>
            </div>
            <div class="tab-panels">
              <div class="tab-panel active" data-tab="cargo">
                <div class="code-block">
                  <pre><code class="language-bash">cargo install blendwerk</code></pre>
                </div>
                <div style="padding: var(--space-md) var(--space-lg); border-top: 1px solid var(--color-border);">
                  <p style="margin: 0; color: var(--color-text-muted);">
                    Available on <a href="https://crates.io/crates/blendwerk" style="color: var(--color-primary);">crates.io</a>
                  </p>
                </div>
              </div>
              <div class="tab-panel" data-tab="binary">
                <div style="padding: var(--space-lg); background-color: var(--color-bg-code);">
                  <p style="margin: 0 0 1rem 0;">Download pre-built binaries from GitHub Releases:</p>
                  <a href="https://github.com/jakobwesthoff/blendwerk/releases" class="btn btn-primary">
                    <svg class="icon-download" viewBox="0 0 24 24">
                      <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                      <polyline points="7 10 12 15 17 10"/>
                      <line x1="12" y1="15" x2="12" y2="3"/>
                    </svg>
                    View Releases
                  </a>
                </div>
              </div>
              <div class="tab-panel" data-tab="source">
                <div class="code-block">
                  <pre><code class="language-bash">git clone https://github.com/jakobwesthoff/blendwerk.git
cd blendwerk
cargo build --release</code></pre>
                </div>
              </div>
            </div>
          </div>

          <h3>Basic Usage</h3>
          <div class="code-block">
            <pre><code class="language-bash"># Create a mock
mkdir -p mocks/api/users
cat > mocks/api/users/GET.json &lt;&lt; 'EOF'
---
status: 200
---
{"users": [{"id": 1, "name": "Alice"}]}
EOF

# Run
blendwerk ./mocks

# Test
curl http://localhost:8080/api/users</code></pre>
          </div>
        </div>
      </div>
    </section>

    <!-- Documentation Section -->
    <section id="docs" class="docs">
      <div class="container">
        <div class="docs-content">
          <h2>Documentation</h2>

          <p>
            Point blendwerk at a directory and it serves mock HTTP/HTTPS responses based on the file structure. No configuration needed &mdash; just files and folders.
          </p>
          <div class="code-block">
            <pre><code class="language-bash">blendwerk &lt;DIRECTORY&gt; [OPTIONS]</code></pre>
          </div>

          <!-- Core Concepts -->
          <h3>Directory Structure Maps to Routes</h3>
          <p>
            Your directory structure IS your API. Folders become URL paths, filenames become HTTP methods. That's it.
          </p>
          <div class="code-block">
            <pre><code class="language-bash">mocks/
├── api/
│   ├── users/
│   │   ├── GET.json          # GET /api/users
│   │   ├── POST.json         # POST /api/users
│   │   └── [id]/             # Path parameter
│   │       ├── GET.json      # GET /api/users/:id
│   │       ├── PUT.json      # PUT /api/users/:id
│   │       └── DELETE.json   # DELETE /api/users/:id
│   └── health/
│       └── GET.json          # GET /api/health
└── GET.html                  # GET /</code></pre>
          </div>
          <p><strong>Rules:</strong></p>
          <ul>
            <li>Method names are case-insensitive (<code>GET.json</code>, <code>get.json</code>, <code>Get.json</code> all work)</li>
            <li>Use <code>[paramName]</code> directories for path parameters (matches any path segment)</li>
            <li>Hot-reload: changes to files are detected automatically</li>
          </ul>

          <!-- Response Files -->
          <h3>Response Files</h3>
          <p>
            Response files use optional YAML frontmatter followed by the response body:
          </p>
          <div class="code-block">
            <pre><code class="language-yaml">---
status: 201
headers:
  X-Request-Id: abc-123
  Cache-Control: no-cache
delay: 100
---
{"created": true, "id": 42}</code></pre>
          </div>

          <h4>Frontmatter Fields</h4>
          <div class="docs-table">
            <table class="table">
              <thead>
                <tr>
                  <th>Field</th>
                  <th>Type</th>
                  <th>Default</th>
                  <th>Description</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td><code>status</code></td>
                  <td>integer</td>
                  <td>200</td>
                  <td>HTTP status code</td>
                </tr>
                <tr>
                  <td><code>headers</code></td>
                  <td>map</td>
                  <td>{}</td>
                  <td>Response headers</td>
                </tr>
                <tr>
                  <td><code>delay</code></td>
                  <td>integer</td>
                  <td>0</td>
                  <td>Delay in milliseconds before responding</td>
                </tr>
              </tbody>
            </table>
          </div>
          <p style="margin-top: var(--space-md);">All fields are optional. Files without frontmatter return status 200.</p>

          <h4>Content-Type</h4>
          <p>
            Automatically inferred from file extension (can be overridden in <code>headers</code>):
          </p>
          <ul>
            <li><code>.json</code> &rarr; <code>application/json</code></li>
            <li><code>.html</code> &rarr; <code>text/html</code></li>
            <li><code>.xml</code> &rarr; <code>application/xml</code></li>
            <li><code>.txt</code> &rarr; <code>text/plain</code></li>
          </ul>

          <h4>Examples</h4>
          <p><strong>Error response:</strong></p>
          <div class="code-block">
            <pre><code class="language-yaml"># mocks/api/protected/GET.json
---
status: 401
headers:
  WWW-Authenticate: Bearer realm="api"
---
{"error": "unauthorized"}</code></pre>
          </div>
          <p><strong>Simulating latency:</strong></p>
          <div class="code-block">
            <pre><code class="language-yaml"># mocks/api/slow/GET.json
---
delay: 2000
---
{"message": "This took 2 seconds"}</code></pre>
          </div>
          <p><strong>Multiple methods:</strong></p>
          <div class="code-block">
            <pre><code class="language-bash"># mocks/api/items/GET.json
{"items": []}

# mocks/api/items/POST.json
---
status: 201
---
{"created": true}</code></pre>
          </div>

          <!-- Configuration -->
          <h3>CLI Options</h3>
          <div class="docs-table">
            <table class="table">
              <thead>
                <tr>
                  <th>Option</th>
                  <th>Default</th>
                  <th>Description</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td><code>&lt;DIRECTORY&gt;</code></td>
                  <td>Required</td>
                  <td>Directory containing mock responses</td>
                </tr>
                <tr>
                  <td><code>-p, --http-port &lt;PORT&gt;</code></td>
                  <td>8080</td>
                  <td>HTTP port</td>
                </tr>
                <tr>
                  <td><code>-s, --https-port &lt;PORT&gt;</code></td>
                  <td>8443</td>
                  <td>HTTPS port</td>
                </tr>
                <tr>
                  <td><code>--http-only</code></td>
                  <td>&mdash;</td>
                  <td>Only serve HTTP (no HTTPS)</td>
                </tr>
                <tr>
                  <td><code>--https-only</code></td>
                  <td>&mdash;</td>
                  <td>Only serve HTTPS (no HTTP)</td>
                </tr>
                <tr>
                  <td><code>--cert-mode &lt;MODE&gt;</code></td>
                  <td>self-signed</td>
                  <td>Certificate mode: none, self-signed, or custom</td>
                </tr>
                <tr>
                  <td><code>--cert-file &lt;PATH&gt;</code></td>
                  <td>&mdash;</td>
                  <td>Path to certificate file (for custom mode)</td>
                </tr>
                <tr>
                  <td><code>--key-file &lt;PATH&gt;</code></td>
                  <td>&mdash;</td>
                  <td>Path to private key file (for custom mode)</td>
                </tr>
                <tr>
                  <td><code>--request-log &lt;DIR&gt;</code></td>
                  <td>&mdash;</td>
                  <td>Directory to log all incoming requests</td>
                </tr>
                <tr>
                  <td><code>--request-log-format</code></td>
                  <td>json</td>
                  <td>Format for request logs (json/yaml)</td>
                </tr>
              </tbody>
            </table>
          </div>

          <!-- HTTP/HTTPS Modes -->
          <h3>HTTP/HTTPS Modes</h3>
          <p><strong>Default (HTTP + HTTPS with self-signed cert):</strong></p>
          <div class="code-block">
            <pre><code class="language-bash">blendwerk ./mocks
# HTTP on :8080, HTTPS on :8443</code></pre>
          </div>
          <p><strong>HTTP only:</strong></p>
          <div class="code-block">
            <pre><code class="language-bash">blendwerk ./mocks --http-only
# or
blendwerk ./mocks --cert-mode none</code></pre>
          </div>
          <p><strong>HTTPS only:</strong></p>
          <div class="code-block">
            <pre><code class="language-bash">blendwerk ./mocks --https-only</code></pre>
          </div>
          <p><strong>Custom certificate:</strong></p>
          <div class="code-block">
            <pre><code class="language-bash">blendwerk ./mocks --cert-mode custom --cert-file server.crt --key-file server.key</code></pre>
          </div>

          <!-- Request Logging -->
          <h3>Request Logging</h3>
          <p>
            blendwerk can log all incoming requests to a directory structure that mirrors your API routes. Useful for debugging, testing, and understanding how your mock API is being used.
          </p>
          <p><strong>Enable request logging:</strong></p>
          <div class="code-block">
            <pre><code class="language-bash">blendwerk ./mocks --request-log ./request-logs</code></pre>
          </div>
          <p><strong>Directory structure:</strong></p>
          <div class="code-block">
            <pre><code class="language-bash">request-logs/
├── api/
│   └── users/
│       ├── GET/
│       │   ├── 2025-01-28T15-30-45.123456Z_01HQKP6J9Z0000000000000000.json
│       │   └── 2025-01-28T15-31-12.456789Z_01HQKP7A1A0000000000000000.json
│       └── POST/
│           └── 2025-01-28T15-32-00.789012Z_01HQKP8B2B0000000000000000.json</code></pre>
          </div>
          <p><strong>Log file format:</strong></p>
          <div class="code-block">
            <pre><code class="language-json">{
  "metadata": {
    "timestamp": "2025-01-28T15-30-45.123456Z",
    "request_id": "01HQKP6J9Z0000000000000000"
  },
  "request": {
    "method": "GET",
    "uri": "/api/users?page=2",
    "path": "/api/users",
    "query": "page=2",
    "headers": {
      "user-agent": "curl/8.0.0",
      "accept": "*/*"
    },
    "body": null,
    "matched_route": "/api/users"
  },
  "response": {
    "status": 200,
    "headers": {
      "content-type": "application/json"
    },
    "body": "{\"users\": [...]}",
    "delay_ms": 0
  }
}</code></pre>
          </div>
          <p><strong>YAML format:</strong></p>
          <div class="code-block">
            <pre><code class="language-bash">blendwerk ./mocks --request-log ./request-logs --request-log-format yaml</code></pre>
          </div>
          <p>
            Filenames use ISO 8601 timestamps plus ULIDs for sortability and uniqueness. Logging happens asynchronously and doesn't block responses. 404s are logged to their requested paths.
          </p>

          <!-- Docker Container Support -->
          <h3>Docker Container Support</h3>
          <p>
            blendwerk properly handles running as PID 1, so you can run it directly in containers without worrying about zombie processes or signal handling. When running as PID 1 (the init process), it automatically:
          </p>
          <ul>
            <li>Reaps zombie processes</li>
            <li>Handles SIGTERM and SIGINT for graceful shutdown</li>
            <li>Forwards signals to child processes</li>
          </ul>
          <p>This behavior is <strong>autodetected</strong> and requires no configuration:</p>
          <div class="code-block">
            <pre><code class="language-dockerfile">FROM scratch
COPY blendwerk /blendwerk
COPY mocks /mocks
ENTRYPOINT ["/blendwerk"]
CMD ["/mocks"]</code></pre>
          </div>

          <!-- Route Matching -->
          <h3>Route Matching</h3>
          <p>
            When multiple routes could match a request, blendwerk uses <strong>first-match-wins</strong> ordering. Routes are matched in the order they're discovered during directory scanning.
          </p>
          <h4>Static vs Dynamic Routes</h4>
          <p>
            Static routes (exact paths) and dynamic routes (with <code>[param]</code> segments) are treated equally &mdash; the first match wins. If you need a specific path to take precedence:
          </p>
          <div class="code-block">
            <pre><code class="language-bash">mocks/api/users/
├── admin/
│   └── GET.json      # GET /api/users/admin (static)
└── [id]/
    └── GET.json      # GET /api/users/:id (dynamic)</code></pre>
          </div>
          <p>
            Both routes exist, and requests to <code>/api/users/admin</code> will match the static route if it's discovered first.
          </p>

          <h4>Multiple Path Parameters</h4>
          <p>
            You can use multiple <code>[param]</code> segments for nested resources:
          </p>
          <div class="code-block">
            <pre><code class="language-bash">mocks/api/users/[userId]/posts/[postId]/
├── GET.json          # GET /api/users/:userId/posts/:postId
├── PUT.json          # PUT /api/users/:userId/posts/:postId
└── DELETE.json       # DELETE /api/users/:userId/posts/:postId</code></pre>
          </div>

          <h4>Error Responses</h4>
          <p>
            blendwerk returns appropriate HTTP status codes for unmatched requests:
          </p>
          <div class="docs-table">
            <table class="table">
              <thead>
                <tr>
                  <th>Status</th>
                  <th>When Returned</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td><code>404 Not Found</code></td>
                  <td>No route matches the requested path</td>
                </tr>
                <tr>
                  <td><code>405 Method Not Allowed</code></td>
                  <td>Path exists but requested HTTP method isn't defined</td>
                </tr>
              </tbody>
            </table>
          </div>

          <!-- Query Parameters -->
          <h3>Query Parameters</h3>
          <p>
            Query strings do <strong>not</strong> affect route matching &mdash; all requests to a path use the same mock response regardless of query parameters:
          </p>
          <div class="code-block">
            <pre><code class="language-bash"># All these hit the same mock: mocks/api/users/GET.json
curl http://localhost:8080/api/users
curl http://localhost:8080/api/users?page=1
curl http://localhost:8080/api/users?page=2&amp;limit=10</code></pre>
          </div>
          <p>
            However, query parameters <strong>are logged</strong> when request logging is enabled, so you can see exactly what your application is requesting.
          </p>

          <!-- Request Logging Details -->
          <h3>Request Logging Details</h3>
          <p>
            Understanding the logged fields:
          </p>
          <div class="docs-table">
            <table class="table">
              <thead>
                <tr>
                  <th>Field</th>
                  <th>Description</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td><code>path</code></td>
                  <td>The literal request path (e.g., <code>/api/users/42</code>)</td>
                </tr>
                <tr>
                  <td><code>matched_route</code></td>
                  <td>The route pattern that matched (e.g., <code>/api/users/:id</code>)</td>
                </tr>
                <tr>
                  <td><code>query</code></td>
                  <td>Query string if present, otherwise <code>null</code></td>
                </tr>
              </tbody>
            </table>
          </div>
          <p>
            <strong>404 requests</strong> are also logged to their requested paths. A request to <code>/nonexistent/path</code> creates a log file at <code>request-logs/nonexistent/path/GET/...</code>
          </p>

          <!-- Cookbook -->
          <h3>Cookbook</h3>
          <p><strong>RESTful CRUD API:</strong></p>
          <div class="code-block">
            <pre><code class="language-bash">mocks/api/users/
├── GET.json                  # List users
├── POST.json                 # Create user (status: 201)
└── [id]/
    ├── GET.json              # Get single user
    ├── PUT.json              # Update user
    └── DELETE.json           # Delete user (status: 204, empty body)</code></pre>
          </div>
          <p><strong>Error responses with custom headers:</strong></p>
          <div class="code-block">
            <pre><code class="language-yaml"># mocks/api/admin/GET.json
---
status: 403
headers:
  X-Error-Code: FORBIDDEN
  X-Error-Message: Admin access required
---
{"error": "forbidden", "message": "Admin access required"}</code></pre>
          </div>
          <p><strong>CORS preflight response:</strong></p>
          <div class="code-block">
            <pre><code class="language-yaml"># mocks/api/data/OPTIONS.json
---
status: 204
headers:
  Access-Control-Allow-Origin: "*"
  Access-Control-Allow-Methods: GET, POST, PUT, DELETE
  Access-Control-Allow-Headers: Content-Type, Authorization
---</code></pre>
          </div>
          <p><strong>Simulating slow API (rate limiting test):</strong></p>
          <div class="code-block">
            <pre><code class="language-yaml"># mocks/api/heavy-operation/POST.json
---
delay: 3000
status: 202
---
{"status": "processing", "estimatedTime": "3 seconds"}</code></pre>
          </div>
          <p><strong>Override Content-Type:</strong></p>
          <div class="code-block">
            <pre><code class="language-yaml"># mocks/api/legacy/GET.json - serve JSON with custom content type
---
headers:
  Content-Type: application/vnd.api+json
---
{"data": {"type": "users", "id": "1"}}</code></pre>
          </div>

          <!-- Limitations -->
          <h3>Limitations</h3>
          <p>
            <strong>Memory Usage:</strong> blendwerk loads all mock response files into memory at startup (and on hot-reload). This keeps things fast for development and testing, but means you probably shouldn't throw gigabyte-sized files at it. If you're mocking endpoints that return large binary chunks, keep an eye on your RAM.
          </p>
          <p>
            <strong>Text Files Only:</strong> Response files are read as UTF-8 text. Binary responses (images, PDFs) are not supported &mdash; attempting to serve binary files may result in corrupted output.
          </p>
          <p>
            <strong>Static Responses:</strong> Responses are static &mdash; you cannot vary the response based on request body, headers, or query parameters. Each <code>(method, path)</code> combination returns the same response every time.
          </p>
          <p>
            <strong>Production Use:</strong> blendwerk is great for local development, integration testing, and temporary mock services. But it's not nginx. It's not built to be a battle-hardened production web server handling millions of requests. For what it's designed to do &mdash; providing quick, file-based API mocks &mdash; it does it well.
          </p>
        </div>
      </div>
    </section>
  </main>

  <!-- Footer -->
  <footer class="footer">
    <div class="container">
      <div class="footer-content">
        <p class="footer-tagline">Your API, mocked in seconds</p>
        <p class="footer-credit">
          Made with <span class="footer-heart">&hearts;</span> by
          <a href="https://westhoffswelt.de">Jakob Westhoff</a> |
          <a href="https://crates.io/crates/blendwerk">crates.io</a> |
          <a href="imprint.html">Imprint/Impressum</a>
        </p>
      </div>
    </div>
  </footer>
  <!-- Prism.js syntax highlighting -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.30.0/prism.min.js" integrity="sha512-HiD3V4nv8fcjtouznjT9TqDNDm1EXngV331YGbfVGeKUoH+OLkRTCMzA34ecjlgSQZpdHZupdSrqHY+Hz3l6uQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.30.0/components/prism-bash.min.js" integrity="sha512-whYhDwtTmlC/NpZlCr6PSsAaLOrfjVg/iXAnC4H/dtiHawpShhT2SlIMbpIhT/IL/NrpdMm+Hq2C13+VKpHTYw==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.30.0/components/prism-yaml.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.30.0/components/prism-json.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.30.0/components/prism-docker.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

  <!-- Tab switching -->
  <script>
    document.querySelectorAll('.tab-button').forEach(button => {
      button.addEventListener('click', () => {
        const tab = button.dataset.tab;
        const tabs = button.closest('.tabs');
        tabs.querySelectorAll('.tab-button').forEach(b => b.classList.remove('active'));
        tabs.querySelectorAll('.tab-panel').forEach(p => p.classList.remove('active'));
        button.classList.add('active');
        tabs.querySelector(`.tab-panel[data-tab="${tab}"]`).classList.add('active');
      });
    });

    // Scroll spy for navbar
    const sections = document.querySelectorAll('section[id]');
    const navLinks = document.querySelectorAll('.navbar-nav a');
    const navbar = document.querySelector('.navbar');
    // Extra 16px buffer makes sections activate slightly early for snappier feel
    const navOffset = navbar.offsetHeight + 16;

    function updateActiveNav() {
      const scrollPos = window.scrollY + navOffset;
      let currentSection = null;

      sections.forEach(section => {
        const top = section.offsetTop;
        const height = section.offsetHeight;

        if (scrollPos >= top && scrollPos < top + height) {
          currentSection = section.getAttribute('id');
        }
      });

      navLinks.forEach(link => {
        link.classList.remove('active');
        if (currentSection && link.getAttribute('href') === `#${currentSection}`) {
          link.classList.add('active');
        }
      });
    }

    window.addEventListener('scroll', updateActiveNav);
    updateActiveNav();
  </script>
</body>
</html>
